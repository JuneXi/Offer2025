# 贪心算法系统总结 Greedy Algorithm Comprehensive Summary

---

## 一、核心思想 Core Concept

**定义 Definition**  
贪心算法在每一步都作出当前看来最优的选择（局部最优），希望最终得到全局最优。  
Greedy algorithm makes the best choice at each step (locally optimal) in hopes of achieving the global optimum.

**关键条件 Key Conditions**  
1. **贪心选择性质 Greedy Choice Property**：局部最优能导向全局最优。  
   Local optimal choice leads to global optimum.  
2. **无后效性 No Aftereffect Property**：当前决策不会影响后续可行性或最优性。  
   Current decisions do not affect future feasibility or optimality.

**基本步骤 Steps**
1. 明确目标 Define the optimization goal (minimize or maximize).  
2. 验证贪心性质与无后效性 Verify greedy choice and no aftereffect.  
3. 设计贪心标准 Design greedy selection rule.  
4. 按标准逐步选择直到结束 Select iteratively according to rule until completion.

---

## 二、主要题型与典型例题 Main Types and Examples

---

### 1. 区间调度类 Interval Scheduling

**例题 Example:** LeetCode 435 Non-overlapping Intervals  
**题干 Summary:**  
给定若干区间，删除最少的区间，使剩余区间不重叠。  
Given intervals, remove the fewest to make remaining intervals non-overlapping.

**贪心思路 Greedy Idea:**  
按结束时间排序，每次选择结束最早且不冲突的区间。  
Sort by end time; choose intervals ending earliest without overlap.

**代码 Code:**
```java
int eraseOverlapIntervals(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));
    int keep = 0, lastEnd = Integer.MIN_VALUE;
    for (int[] it : intervals) {
        if (it[0] >= lastEnd) {
            keep++;
            lastEnd = it[1];
        }
    }
    return intervals.length - keep;
}
```

**贪心理由 Reason:**  
结束最早的区间为后续留最大空间。  
Choosing the earliest ending interval leaves maximum room for others.

---

### 2. 区间覆盖类 Interval Covering

**例题 Example:** LeetCode 1024 Video Stitching  
**题干 Summary:**  
最少视频片段覆盖 [0,T]。  
Use the fewest video clips to cover [0, T].

**贪心思路 Greedy Idea:**  
在当前可达范围内选右端最远的片段。  
Within current reach, choose the clip with the farthest end.

**代码 Code:**
```java
int videoStitching(int[][] clips, int T) {
    Arrays.sort(clips, (a, b) -> a[0] - b[0]);
    int res = 0, end = 0, nextEnd = 0, i = 0;
    while (end < T) {
        while (i < clips.length && clips[i][0] <= end)
            nextEnd = Math.max(nextEnd, clips[i++][1]);
        if (nextEnd == end) return -1;
        res++;
        end = nextEnd;
    }
    return res;
}
```

**贪心理由 Reason:**  
每次延伸最远能最小化拼接次数。  
Extending farthest at each step minimizes number of segments.

---

### 3. 最小代价类 Minimum Cost (MST)

**例题 Example:** LeetCode 1584 Min Cost to Connect All Points  
**题干 Summary:**  
连接所有点的最小代价。  
Connect all points with minimum total cost.

**贪心思路 Greedy Idea:**  
Prim 算法：每次选择最小权边连接未加入节点。  
Prim’s algorithm: each step selects the smallest edge to expand the tree.

**代码 Code:**
```java
int minCostConnectPoints(int[][] points) {
    int n = points.length;
    boolean[] inTree = new boolean[n];
    int[] minDist = new int[n];
    Arrays.fill(minDist, Integer.MAX_VALUE);
    minDist[0] = 0;
    int res = 0;

    for (int i = 0; i < n; i++) {
        int u = -1;
        for (int j = 0; j < n; j++) {
            if (!inTree[j] && (u == -1 || minDist[j] < minDist[u])) u = j;
        }
        inTree[u] = true;
        res += minDist[u];
        for (int v = 0; v < n; v++) {
            if (!inTree[v]) {
                int w = Math.abs(points[u][0] - points[v][0]) +
                        Math.abs(points[u][1] - points[v][1]);
                if (w < minDist[v]) minDist[v] = w;
            }
        }
    }
    return res;
}
```

**贪心理由 Reason:**  
最小割边选择保证最优。  
Choosing minimum cut edge guarantees global optimality.

---

### 4. 路径优化类 Path Optimization (Dijkstra)

**例题 Example:** Dijkstra Shortest Path  
**题干 Summary:**  
求单源最短路径（非负权图）。  
Find single-source shortest paths in a non-negative weighted graph.

**思路 Idea:**  
每次取未确定中距离最小点，松弛邻边。  
Pick smallest distance node, relax edges.

**代码 Code:**
```java
int[] dijkstra(int n, int[][] edges, int src) {
    List<int[]>[] g = new ArrayList[n];
    for (int i = 0; i < n; i++) g[i] = new ArrayList<>();
    for (int[] e : edges) g[e[0]].add(new int[]{e[1], e[2]});

    int[] dist = new int[n];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[src] = 0;

    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
    pq.offer(new int[]{src, 0});
    boolean[] vis = new boolean[n];

    while (!pq.isEmpty()) {
        int[] cur = pq.poll();
        int u = cur[0];
        if (vis[u]) continue;
        vis[u] = true;
        for (int[] e : g[u]) {
            int v = e[0], w = e[1];
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.offer(new int[]{v, dist[v]});
            }
        }
    }
    return dist;
}
```

**贪心理由 Reason:**  
已确定节点距离不会变短。  
Once fixed, a node’s distance never improves.

---

### 5. 作业调度类 Job Scheduling

**例题 Example:** LeetCode 1235 Maximum Profit in Job Scheduling  
**题干 Summary:**  
有作业 (start,end,profit)，选不重叠作业最大化利润。  
Given jobs (start,end,profit), choose non-overlapping ones to maximize total profit.

**思路 Idea:**  
按结束时间排序，用二分找前一个不冲突任务。  
Sort by end time, use binary search for previous non-conflicting job.

**代码 Code:** (see original)
