# 背包问题与相关动态规划（含硬币找零与排列组合）

> 语言：Java  
> 说明：系统整理 0-1 背包、完全背包、多重背包、分组背包与硬币找零问题。  
> 格式清晰，可直接保存为 `.md`。


## 一、核心总览表

| 背包类型 | 每个物品可用次数 | 外层循环 | 内层循环方向 | 原因解释 |
|-----------|------------------|-----------|----------------|------------|
| **0-1 背包** | 每种物品最多 1 次 | 物品 | `j = W → w[i]`（**倒序**） | 倒序防止同一物品被重复使用（覆盖旧状态） |
| **完全背包** | 每种物品无限次 | 物品 | `j = w[i] → W`（**正序**） | 正序允许当前物品重复使用 |
| **多重背包** | 每种物品有限次 | 物品（或拆分子物品） | `j = W → w[i]`（**倒序**） | 分解后相当于多个 0-1 物品 |
| **分组背包** | 每组最多选 1 个 | 组 | `j = W → 0`（**倒序**） | 同组物品不能共存 |
| **二维背包（如 findMaxForm）** | 每件物品最多 1 次 | 物品 | `i = M → 0`, `j = N → 0`（**双倒序**） | 防止同一物品重复加入 |
| **硬币找零 - 组合数** | 每种硬币无限次 | 硬币 | `sum = coin → amount`（**正序**） | 完全背包计数，顺序不敏感 |
| **硬币找零 - 排列数** | 每种硬币无限次 | 金额 | `for coin : coins`（**内层**） | 顺序敏感，每个金额累加前驱 |
| **硬币找零 - 最少硬币数** | 每种硬币无限次 | 硬币 | `sum = coin → amount`（**正序**） | 完全背包最优化问题 |

---

## 二、通用规律

1. **外层循环是谁**
    - “物品只能用一次” → 外层是 **物品**（0-1 背包）
    - “物品可重复用” → 外层仍是 **物品**（完全背包）
    - “组合问题（顺序不敏感）” → 外层是 **物品/硬币**
    - “排列问题（顺序敏感）” → 外层是 **容量/金额**

2. **内层循环方向**
    - **倒序**：防止重复使用（0-1 背包）
    - **正序**：允许重复使用（完全背包）

---
---

## 目录
1. 0-1 背包  
2. 完全背包  
3. 多重背包  
4. 分组背包  
5. 硬币找零（Coin Change）  
6. 排列数与组合数区别  
7. 遍历顺序汇总  
8. 初始化与复杂度

---

## 1. 0-1 背包（0-1 Knapsack）

**定义**：每件物品最多选一次。  
**DP 含义**：`dp[i][j]` 表示前 `i` 件物品、容量 `j` 时的最大价值。  
### 常见目标

1. 可行性：能否恰好/不超过装满

2. 最大/最小值：最大价值、最小差

3. 计数：方案数（较少见）

4. 多维约束：重量+体积、0和1计数等

### 典型题型/套路

子集和可达性/最接近目标

划分为两子集使差最小

选择若干字符串/任务，满足多维资源限制

利润/人数双约束的方案计数（取模）

### 代表题目

416. Partition Equal Subset Sum（子集和可达性）

Last Stone Weight II（最小差转子集和）

Target Sum（→ 子集和计数 0-1）

Ones and Zeroes（二维 0-1 背包）

Profitable Schemes（二维 0-1 + 计数取模）

遍历提示：外层物品；容量（及各维度）倒序。

### 二维
```java
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= W; j++) {
        dp[i][j] = dp[i-1][j];
        if (j >= w[i]) dp[i][j] = Math.max(dp[i][j], dp[i-1][j-w[i]] + v[i]);
    }
}
```

### 一维（倒序）
```java
for (int i = 1; i <= n; i++)
    for (int j = W; j >= w[i]; j--) // 倒序
        dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]);
```

---

## 2. 完全背包（Unbounded Knapsack）

**定义**：每种物品可无限使用。  
**关系**：硬币找零问题是其特例。  

### 常见目标

最优化：最少件数/最小成本/最大价值

计数：组合数 or 排列数

构造型：用代价拼出目标

### 典型题型/套路

硬币找零：最少硬币数 / 组合数

平方数和、拆分整数最优

用数字成本凑目标，最大“价值”或“字典序”

### 代表题目

322. Coin Change（最少硬币数）

Coin Change 2（组合数，顺序不敏感）

Perfect Squares（最少平方数）

Form Largest Integer With Digits That Add up to Target（成本→最大数）

Combination Sum IV（排列数，顺序敏感，金额外层）

### 遍历提示：外层物品；容量正序（允许重复）。
计数：组合数→硬币外层正序；排列数→金额外层。

### 二维
```java
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= W; j++) {
        dp[i][j] = dp[i-1][j];
        if (j >= w[i]) dp[i][j] = Math.max(dp[i][j], dp[i][j-w[i]] + v[i]);
    }
}
```

### 一维（正序）
```java
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <= W; j++) // 正序
        dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]);
```

---

## 3. 多重背包（Multiple Knapsack）

**定义**：每件物品最多可选 `c[i]` 次。  
**常用优化**：二进制分解成若干 0-1 物品。
### 常见目标

最大/最小值、可行性

计数（较少）

### 典型题型/套路

有库存上限的购买/兑换/体积价值问题

二进制分解或单调队列优化（按模类分组）

### 代表题目

典型“有库存的商品选购”/“有限硬币找零”类（平台题库常见）

（思路）二进制分解→若干 0-1 物品；或对 j % w[i] 做分组单调队列优化

### 遍历提示：转 0-1 后容量倒序；或用分组优化逐类更新。

### 二进制分解后代码（倒序）
```java
for (Item it : itemsAfterSplit)
    for (int j = W; j >= it.w; j--)
        dp[j] = Math.max(dp[j], dp[j-it.w] + it.v);
```

---

## 4. 分组背包（Grouped Knapsack）

**定义**：物品分为若干组，每组最多选一件。  

### 常见目标

最大值/最小成本

多组约束只选一件

### 典型题型/套路

套餐/配置选择：CPU/GPU/内存各选一件使总价值最大

课程/项目分类，每组只能择其一

### 代表题目

经典“配置选择”类（各在线 OJ 常见模板题）

遍历提示：外层组；容量倒序；组内枚举物品取最优。

### 一维实现（组外层，倒序）
```java
for (List<Item> group : groups) {
    for (int j = W; j >= 0; j--) {
        long best = dp[j];
        for (Item it : group)
            if (j >= it.w) best = Math.max(best, dp[j-it.w] + it.v);
        dp[j] = best;
    }
}
```

---

## 5. 硬币找零（Coin Change）

> 属于 **完全背包问题（Unbounded Knapsack）**  
> 根据目标不同，分为两类：  
> - **计数型动态规划**（求方案数）  
> - **最优化动态规划**（求最少硬币数）

### (1) 计数型：求方案数（组合数）
```java
int[] coins = {1,2,5};
int amount = 11;
long[] dp = new long[amount+1];
dp[0] = 1;
for (int coin : coins)
    for (int j = coin; j <= amount; j++) // 正序
        dp[j] += dp[j - coin];
System.out.println(dp[amount]); // 方案数
```

### (2) 最优化型：最少硬币数
```java
int[] coins = {1,2,5};
int amount = 11;
int INF = 1_000_000_000;
int[] dp = new int[amount+1];
Arrays.fill(dp, INF);
dp[0] = 0;
for (int coin : coins)
    for (int j = coin; j <= amount; j++) // 正序
        dp[j] = Math.min(dp[j], dp[j - coin] + 1);
System.out.println(dp[amount] >= INF ? -1 : dp[amount]);
```

---

## 6. 排列数与组合数区别

| 项目 | 组合数（Combination） | 排列数（Permutation） |
|------|-----------------------|-----------------------|
| 顺序是否重要 | 不重要 `{1,2}` = `{2,1}` | 重要 `{1,2}` ≠ `{2,1}` |
| 遍历外层 | 硬币（coin） | 金额（sum） |
| 适用问题 | Coin Change II | Coin Change Permutations |
| 转移方程 | `dp[j] += dp[j - coin]` | `dp[j] += dp[j - coin]`（同式，但顺序不同） |

排列数示例：
```java
int[] coins = {1,2,5};
int amount = 5;
long[] dp = new long[amount+1];
dp[0] = 1;
for (int j = 1; j <= amount; j++) // 外层金额
    for (int coin : coins)
        if (j >= coin) dp[j] += dp[j - coin];
System.out.println(dp[amount]); // 排列数
```

---

## 7. 遍历顺序汇总

| 类型 | j 遍历方向 | 备注 |
|------|-------------|------|
| 0-1 背包 | 倒序 | 防止重复选 |
| 完全背包 | 正序 | 允许重复选 |
| 多重背包（二进制） | 倒序 | 转为若干 0-1 背包 |
| 分组背包 | 倒序 | 每组最多一件 |
| 硬币找零（组合数） | 正序 | 硬币外层 |
| 硬币找零（最少硬币） | 正序 | 硬币外层 |
| 硬币找零（排列数） | 正序 | 金额外层 |

---

## 8. 初始化与复杂度

| 类型 | 初始化 | 时间复杂度 | 空间复杂度 |
|------|----------|-------------|-------------|
| 最大价值 | `dp[0]=0` 其余 0 | O(nW) | O(W) |
| 计数型 | `dp[0]=1` | O(nW) | O(W) |
| 最优化型 | `dp[0]=0` 其余 INF | O(nW) | O(W) |

---

✅ **总结**：  
> 硬币找零问题本质上是**完全背包问题**的两种动态规划形式：  
> - **计数型动态规划**（求方案数）  
> - **最优化动态规划**（求最少硬币数）
