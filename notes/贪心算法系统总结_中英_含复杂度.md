# 贪心算法系统总结 · 中英文对照（含复杂度）
# Greedy Algorithm Comprehensive Summary · Bilingual (with Complexity)

---

## 一、核心思想 Core Concept
**定义 Definition**  
贪心算法在每一步都作出当前看来最优的选择（局部最优），希望最终得到全局最优。  
Greedy algorithm makes the best choice at each step (locally optimal) aiming for a global optimum.

**关键条件 Key Conditions**  
1) 贪心选择性质：局部最优可导向全局最优。/ Greedy-choice property: local ⇒ global.  
2) 无后效性：当前决策不影响后续最优性。/ No aftereffect: current choice does not harm future optimality.

**实现步骤 Steps**  
1) 明确目标 / Define objective.  
2) 验证性质 / Verify properties.  
3) 设定规则 / Set selection rule.  
4) 迭代选择 / Iterate.

---

## 二、主要题型与典型例题 Main Types and Examples

### 1) 区间调度类 Interval Scheduling
**例题 Example**: LeetCode 435 Non-overlapping Intervals  
**题干 Summary**: 删除最少区间使其互不重叠。/ Remove the fewest intervals to avoid overlap.  
**思路 Idea**: 按结束时间升序，能放则放。/ Sort by end time; pick non-overlapping intervals.  
**复杂度 Complexity**:  
- 时间 Time: O(n log n)（排序） / due to sorting.  
- 空间 Space: O(1) 额外或 O(n) 取决于排序实现 / extra, or O(n) depending on sort.

```java
int eraseOverlapIntervals(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));
    int keep = 0, lastEnd = Integer.MIN_VALUE;
    for (int[] it : intervals) {
        if (it[0] >= lastEnd) { keep++; lastEnd = it[1]; }
    }
    return intervals.length - keep;
}
```

---

### 2) 区间覆盖类 Interval Covering
**例题 Example**: LeetCode 1024 Video Stitching  
**题干 Summary**: 最少片段覆盖 [0, T]。/ Min clips to cover [0, T].  
**思路 Idea**: 在当前可达内选右端最远。/ Within reach, pick farthest end.  
**复杂度 Complexity**:  
- 时间 Time: O(n log n)（按起点排序 + 线性扫描）.  
- 空间 Space: O(1) 额外.

```java
int videoStitching(int[][] clips, int T) {
    Arrays.sort(clips, (a, b) -> a[0] - b[0]);
    int res = 0, end = 0, nextEnd = 0, i = 0;
    while (end < T) {
        while (i < clips.length && clips[i][0] <= end)
            nextEnd = Math.max(nextEnd, clips[i++][1]);
        if (nextEnd == end) return -1;
        res++; end = nextEnd;
    }
    return res;
}
```

---

### 3) 最小代价类（MST） Minimum Cost (MST)
**例题 Example**: LeetCode 1584 Min Cost to Connect All Points  
**题干 Summary**: 连接所有点的最小成本（曼哈顿距离）。/ Connect all points with min total cost (Manhattan).  
**思路 Idea**: Prim 贪心扩展最小边。/ Prim: expand by smallest edge.  
**复杂度 Complexity**:  
- 时间 Time: O(n^2)（本实现不使用堆）；用堆可至 O(n^2)~O(n log n) 取决于图结构。  
- 空间 Space: O(n).
- 算法原理（Prim 贪心）：
  每次从未加入的点中选择与生成树距离最小的点加入，并更新其余点到生成树的最短距离，直到所有点都被包含。因为这题要求 连接所有点且总代价最小，而这正是**最小生成树（Minimum Spanning Tree, MST）**问题的定义。


```java
int minCostConnectPoints(int[][] points) {
        int n = points.length;                 // 点数
        boolean[] inTree = new boolean[n];     // 节点是否已加入MST
        int[] minDist = new int[n];            // 各点连到当前MST的最小代价
        Arrays.fill(minDist, Integer.MAX_VALUE);
        minDist[0] = 0;                        // 从0号点起
        int res = 0;                           // MST总成本

        for (int i = 0; i < n; i++) {
            // 选出未在树中且 minDist 最小的点 u
            int u = -1;
            for (int j = 0; j < n; j++) {
                if (!inTree[j] && (u == -1 || minDist[j] < minDist[u])) {
                    u = j;
                }
            }

            inTree[u] = true;          // 将 u 加入树
            res += minDist[u];         // 累加其连接代价（起点为0）

            // 用 u 更新所有未加入点的最小连接代价
            for (int v = 0; v < n; v++) {
                if (!inTree[v]) {
                    int w = Math.abs(points[u][0] - points[v][0])
        + Math.abs(points[u][1] - points[v][1]); // 曼哈顿距离
                        if (w < minDist[v]) minDist[v] = w;
                    }
                }
            }
            return res;
        }

---

### 4) 路径优化类 Path Optimization (Dijkstra)
**例题 Example**: Dijkstra Shortest Path  
**题干 Summary**: 非负权图的单源最短路。/ Single-source shortest paths on non-negative graphs.  
**思路 Idea**: 每次确定当前最小距离节点并松弛。/ Pop min-distance node and relax.  
**复杂度 Complexity**:  
- 时间 Time: O((V + E) log V)（最小堆）.  
- 空间 Space: O(V + E).

```java
int[] dijkstra(int n, int[][] edges, int src) {
    List<int[]>[] g = new ArrayList[n];
    for (int i = 0; i < n; i++) g[i] = new ArrayList<>();
    for (int[] e : edges) g[e[0]].add(new int[]{e[1], e[2]});

    int[] dist = new int[n];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[src] = 0;

    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
    pq.offer(new int[]{src, 0});
    boolean[] vis = new boolean[n];

    while (!pq.isEmpty()) {
        int[] cur = pq.poll();
        int u = cur[0];
        if (vis[u]) continue;
        vis[u] = true;
        for (int[] e : g[u]) {
            int v = e[0], w = e[1];
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.offer(new int[]{v, dist[v]});
            }
        }
    }
    return dist;
}
```

---

### 5) 作业调度类 Job Scheduling
**例题 Example**: LeetCode 1235 Maximum Profit in Job Scheduling  
**题干 Summary**: 选不重叠作业以最大化利润。/ Choose non-overlapping jobs to maximize profit.  
**思路 Idea**: 按结束时间排序 + 二分 + DP。/ Sort by end + binary search + DP.  
**复杂度 Complexity**:  
- 时间 Time: O(n log n)（排序与二分）.  
- 空间 Space: O(n)（DP数组）.

```java
int jobScheduling(int[] start, int[] end, int[] profit) {
        int n = start.length; // 作业数量 / number of jobs

        // jobs[i] = {start time, end time, profit}
        int[][] jobs = new int[n][3];
        for (int i = 0; i < n; i++)
        jobs[i] = new int[]{start[i], end[i], profit[i]};

        // 按结束时间排序（保证后续DP时前缀最优） / sort by end time
        Arrays.sort(jobs, (a, b) -> a[1] - b[1]);

        int[] dp = new int[n]; // dp[i] 表示考虑到第 i 个作业（含）时的最大收益
        dp[0] = jobs[0][2];    // 只有一个作业时收益就是它本身

        // 遍历所有作业
        for (int i = 1; i < n; i++) {
        int incl = jobs[i][2]; // incl 表示包含当前作业 i 的最大收益
        int j = binarySearch(jobs, i); // j 为最后一个结束时间 <= 当前开始时间的作业下标
        if (j != -1) incl += dp[j];    // 若存在不冲突作业，加上它的最优收益
        dp[i] = Math.max(dp[i - 1], incl); // 不选当前作业 or 选当前作业，取最大
        }
        return dp[n - 1]; // 返回考虑完所有作业后的最大收益
        }

/**
 * 在已排序的 jobs[0..i-1] 中，找到最后一个满足 jobs[m].end <= jobs[i].start 的作业索引。
 * 即当前作业 i 可兼容的上一个作业。
 */
        int binarySearch(int[][] jobs, int i) {
        int l = 0, r = i - 1;
        while (l <= r) {
        int m = (l + r) / 2;
        if (jobs[m][1] <= jobs[i][0]) // 若当前作业 m 结束时间 ≤ 当前作业 i 的开始时间
        l = m + 1; // 继续向右找（更靠后的也可能兼容）
        else
        r = m - 1; // 否则向左找
        }
        return r; // 返回最后一个满足条件的作业下标，若没有则为 -1
        }

```

---

### 6) 加油问题类 Refueling
**例题 Example**: LeetCode 871 Minimum Number of Refueling Stops  
**题干 Summary**: 到达目标的最少加油次数。/ Min refuels to reach target.  
**思路 Idea**: 最大堆保存可达站油量，必须时加最大。/ Max-heap of fuels, refuel when needed.  
**复杂度 Complexity**:  
- 时间 Time: O(n log n)（堆操作）.  
- 空间 Space: O(n).

```java
int minRefuelStops(int target, int startFuel, int[][] stations) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
    int fuel = startFuel, count = 0, i = 0;
    while (fuel < target) {
        while (i < stations.length && stations[i][0] <= fuel)
            pq.offer(stations[i++][1]);
        if (pq.isEmpty()) return -1;
        fuel += pq.poll();
        count++;
    }
    return count;
}
```

---

### 7) 零钱问题类 Change / Cashier
**例题 Example**: LeetCode 860 Lemonade Change  
**题干 Summary**: 能否顺利找零。/ Can make change for each customer.  
**思路 Idea**: 优先用大额找零。/ Use larger bills first.  
**复杂度 Complexity**:  
- 时间 Time: O(n).  
- 空间 Space: O(1).

```java
boolean lemonadeChange(int[] bills) {
    int five = 0, ten = 0;
    for (int b : bills) {
        if (b == 5) five++;
        else if (b == 10) {
            if (five == 0) return false;
            five--; ten++;
        } else {
            if (ten > 0 && five > 0) { ten--; five--; }
            else if (five >= 3) five -= 3;
            else return false;
        }
    }
    return true;
}
```

---

### 8) 最优合并类 Optimal Merge (Huffman)
**例题 Example**: Huffman Coding / Minimum Cost to Combine Files  
**题干 Summary**: 合并到一个的最小总代价。/ Min total cost to combine all weights.  
**思路 Idea**: 最小堆每次合并两最小。/ Min-heap, merge two smallest each time.  
**复杂度 Complexity**:  
- 时间 Time: O(n log n).  
- 空间 Space: O(n).

```java
int minCostToCombine(int[] weights) {
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    for (int w : weights) pq.offer(w);
    int cost = 0;
    while (pq.size() > 1) {
        int a = pq.poll(), b = pq.poll();
        int sum = a + b;
        cost += sum;
        pq.offer(sum);
    }
    return cost;
}
```

---

### 9) 区间覆盖变体：补数覆盖 Patching Array
**例题 Example**: LeetCode 330 Patching Array  
**题干 Summary**: 补最少数字使 [1,n] 可由子集和表示。/ Patch minimal numbers so [1,n] is representable by subset sums.  
**思路 Idea**: 维护最小不可覆盖 `miss`；若下一个 ≤ miss，扩展；否则补 `miss`。/ Maintain smallest missing `miss`; extend or patch.  
**复杂度 Complexity**:  
- 时间 Time: O(m + k)，其中 m 为原数组长度，k 为补数次数，且 `k ≤ ⌈log2(n)⌉`。  
- 空间 Space: O(1).

```java
int minPatches(int[] nums, int n) {
    long miss = 1; int i = 0, cnt = 0;
    while (miss <= n) {
        if (i < nums.length && nums[i] <= miss) miss += nums[i++];
        else { miss += miss; cnt++; }
    }
    return cnt;
}
```

---

### 10) 花园浇水 Garden Watering (Interval Covering)
**例题 Example**: LeetCode 1326 Minimum Number of Taps to Open to Water a Garden  
**题干 Summary**: 最少打开水龙头覆盖 [0,n]。/ Min taps to cover [0, n].  
**思路 Idea**: 预处理最远可达右端，按视频拼接贪心滑动。/ Precompute farthest reach then greedy extend.  
**复杂度 Complexity**:  
- 时间 Time: O(n).  
- 空间 Space: O(n).

```java
int minTaps(int n, int[] ranges) {
    int[] far = new int[n + 1];
    for (int i = 0; i <= n; i++) {
        int L = Math.max(0, i - ranges[i]);
        int R = Math.min(n, i + ranges[i]);
        far[L] = Math.max(far[L], R);
    }
    int res = 0, end = 0, nextEnd = 0;
    for (int i = 0; i <= n; i++) {
        if (i > nextEnd) return -1;
        if (i > end) { res++; end = nextEnd; }
        nextEnd = Math.max(nextEnd, far[i]);
    }
    return res;
}
```

---

## 三、区间覆盖贪心统一模板 Unified Template
**复杂度 Complexity**: 排序 O(n log n) + 扫描 O(n)，空间 O(1)。/ Sorting O(n log n) + scan O(n), space O(1).

```java
int greedyCover(Type[] arr, int target) {
    sort(arr); // 按起点或数值升序 / sort by start or value
    int res = 0, end = 0, nextEnd = 0, i = 0;
    while (end < target) {
        while (i < arr.length && arr[i].start <= end)
            nextEnd = Math.max(nextEnd, arr[i].end);
        if (nextEnd == end) return -1;
        res++; end = nextEnd;
    }
    return res;
}
```
