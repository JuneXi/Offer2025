# 手写数据结构模板（Java）Handwritten Data Structures
更新日期 Last Updated: 2025-10-27 02:03

> 目标：实现常考数据结构，保证接口清晰、复杂度达标、可直接粘贴运行。
> 约定：除特别说明，时间复杂度按均摊 / 平均分析。

---


## 目录 Contents
1. LRU Cache（LinkedHashMap 版 + 手写双向链表）  
2. 两个队列实现栈 MyStack  
3. 两个栈实现队列 MyQueue  
4. MinStack（O(1) 取最小）  
5. LFU Cache（O(1)）  
6. 循环队列 Circular Queue  
7. 循环双端队列 Circular Deque  
8. Trie（前缀树）  
9. 并查集 Union-Find（路径压缩 + 启发式合并）  
10. RandomizedSet（O(1) 插删查 + 随机）  
11. 线段树 Segment Tree（区间和，点更新）  
12. 树状数组 Fenwick Tree（区间和，点更新）  
13. 单调队列 Monotonic Queue（滑动窗口最大值）

---

## 1) LRU Cache

Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

1. LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
2. int get(int key) Return the value of the key if the key exists, otherwise return -1.
3. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
4. The functions get and put must each run in O(1) average time complexity.

### 1A. 基于 LinkedHashMap（最短）
- 思路：access-order + removeEldestEntry。  
- 复杂度：`get/put` O(1)。

```java
import java.util.*;

class LRUCache extends LinkedHashMap<Integer, Integer> {
    private final int cap;
    public LRUCache(int capacity) {
        super(capacity, 0.75f, true); // access-order
        this.cap = capacity;
    }
    public int get(int key) { return super.getOrDefault(key, -1); }
    public void put(int key, int value) { super.put(key, value); }
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer,Integer> e) {
        return size() > cap;
    }
}
```

### 1B. 手写双向链表 + HashMap（面试常考）
- 思路：HashMap 定位节点，双向链表维护 LRU 顺序（头最近、尾最远）。  
- 复杂度：`get/put` O(1)，空间 O(n)。

```java
import java.util.*;

class LRUCacheManual {
    static class Node {
        int k, v; Node prev, next;
        Node(int k, int v){ this.k=k; this.v=v; }
    }
    private final int cap;
    private final Map<Integer, Node> map = new HashMap<>();
    private final Node head = new Node(-1,-1), tail = new Node(-1,-1);

    public LRUCacheManual(int capacity){
        this.cap = capacity;
        head.next = tail; tail.prev = head;
    }

    public int get(int key){
        Node n = map.get(key);
        if(n==null) return -1;
        moveToHead(n);
        return n.v;
    }

    public void put(int key, int value){
        Node n = map.get(key);
        if(n!=null){
            n.v = value;
            moveToHead(n);
            return;
        }
        if(map.size()==cap){
            Node rm = tail.prev;
            remove(rm);
            map.remove(rm.k);
        }
        Node x = new Node(key, value);
        addToHead(x);
        map.put(key, x);
    }

    private void moveToHead(Node n){ remove(n); addToHead(n); }
    private void remove(Node n){ n.prev.next = n.next; n.next.prev = n.prev; }
    private void addToHead(Node n){
        n.next = head.next; n.prev = head;
        head.next.prev = n; head.next = n;
    }
}
```

---

## 2) 两个队列实现栈 MyStack

### 2A. push O(n)，pop/top O(1)（推荐）
```java
import java.util.*;

class MyStack {
    Queue<Integer> q1 = new ArrayDeque<>(), q2 = new ArrayDeque<>();
    public void push(int x){
        q2.offer(x);
        while(!q1.isEmpty()) q2.offer(q1.poll());
        Queue<Integer> t = q1; q1 = q2; q2 = t;
    }
    public int pop(){ return q1.poll(); }
    public int top(){ return q1.peek(); }
    public boolean empty(){ return q1.isEmpty(); }
}
```

### 2B. push O(1)，pop/top O(n)
```java
import java.util.*;

class MyStack2 {
    Queue<Integer> q1 = new ArrayDeque<>(), q2 = new ArrayDeque<>();
    public void push(int x){ q1.offer(x); }
    public int pop(){
        while(q1.size()>1) q2.offer(q1.poll());
        int ans = q1.poll();
        Queue<Integer> t=q1; q1=q2; q2=t;
        return ans;
    }
    public int top(){
        while(q1.size()>1) q2.offer(q1.poll());
        int ans = q1.peek();
        q2.offer(q1.poll());
        Queue<Integer> t=q1; q1=q2; q2=t;
        return ans;
    }
    public boolean empty(){ return q1.isEmpty(); }
}
```

---

## 3) 两个栈实现队列 MyQueue
- 思路：in 栈入，out 栈出；out 空时把 in 全倒过去。  
- 复杂度：均摊 O(1)。

```java
import java.util.*;

class MyQueue {
    Deque<Integer> in = new ArrayDeque<>();
    Deque<Integer> out = new ArrayDeque<>();
    public void push(int x){ in.push(x); }
    public int pop(){ move(); return out.pop(); }
    public int peek(){ move(); return out.peek(); }
    public boolean empty(){ return in.isEmpty() && out.isEmpty(); }
    private void move(){
        if(out.isEmpty())
            while(!in.isEmpty()) out.push(in.pop());
    }
}
```

---

## 4) MinStack（O(1) 取最小）

### 思路说明
使用两个栈：
- **data 栈**：存储所有元素。
- **mins 栈**：同步维护当前最小值，保证栈顶始终是当前最小。

操作逻辑：
1. **push(x)**
    - 压入 data；
    - 若 mins 为空或 x ≤ mins 栈顶，则同时压入 mins。
2. **pop()**
    - 从 data 弹出；
    - 若弹出的值等于 mins 栈顶，也弹出 mins。
3. **top()**
    - 返回 data 栈顶。
4. **getMin()**
    - 返回 mins 栈顶。

所有操作均为 **O(1)**。

---

## Java 实现（带注释）

```java
class MinStack {
    private Stack<Integer> data;  // 主栈，存放所有元素
    private Stack<Integer> mins;  // 辅助栈，存放最小值

    public MinStack() {
        data = new Stack<>();
        mins = new Stack<>();
    }

    // 入栈操作
    public void push(int x) {
        data.push(x);
        // 若辅助栈为空或新元素小于等于当前最小值，则入辅助栈
        if (mins.isEmpty() || x <= mins.peek()) {
            mins.push(x);
        }
    }

    // 出栈操作
    public void pop() {
        int val = data.pop();
        // 若弹出的正是当前最小值，同步弹出辅助栈
        if (val == mins.peek()) {
            mins.pop();
        }
    }

    // 查看栈顶元素
    public int top() {
        return data.peek();
    }

    // 获取最小值
    public int getMin() {
        return mins.peek();
    }
}
```

---

## 5) LFU Cache（O(1)）
- 思路：`key -> Node(k,v,freq)`；`freq -> 双向链表`；维护 `minFreq`。  
- 操作：命中时 freq++ 并迁移到新频次链；淘汰最旧且 freq 最小。

```java
import java.util.*;

class LFUCache {
    static class Node {
        int k, v, f = 1;
        Node prev, next;
        Node(int k, int v){ this.k=k; this.v=v; }
    }
    static class DL {
        Node head = new Node(-1,-1), tail = new Node(-1,-1);
        int size = 0;
        DL(){ head.next=tail; tail.prev=head; }
        void addFirst(Node x){
            x.next=head.next; x.prev=head;
            head.next.prev=x; head.next=x; size++;
        }
        void remove(Node x){ x.prev.next=x.next; x.next.prev=x.prev; size--; }
        Node removeLast(){ if(size==0) return null; Node x=tail.prev; remove(x); return x; }
    }

    private final int cap;
    private int minFreq = 0;
    private final Map<Integer, Node> keyMap = new HashMap<>();
    private final Map<Integer, DL> freqMap = new HashMap<>();

    public LFUCache(int capacity){ this.cap = capacity; }

    public int get(int key){
        Node n = keyMap.get(key);
        if(n==null) return -1;
        touch(n);
        return n.v;
    }

    public void put(int key, int value){
        if(cap==0) return;
        if(keyMap.containsKey(key)){
            Node n = keyMap.get(key);
            n.v = value;
            touch(n);
            return;
        }
        if(keyMap.size()==cap){
            DL list = freqMap.get(minFreq);
            Node rm = list.removeLast();
            keyMap.remove(rm.k);
        }
        Node x = new Node(key, value);
        keyMap.put(key, x);
        freqMap.computeIfAbsent(1, z->new DL()).addFirst(x);
        minFreq = 1;
    }

    private void touch(Node n){
        int f = n.f;
        DL list = freqMap.get(f);
        list.remove(n);
        if(f==minFreq && list.size==0) minFreq++;
        n.f++;
        freqMap.computeIfAbsent(n.f, z->new DL()).addFirst(n);
    }
}
```

---

## 6) 循环队列 Circular Queue
- 思路：数组 + 头尾指针 + 取模；保留空位或维护 size。

```java
class MyCircularQueue {
    int[] q; int head=0, tail=0, size=0;
    public MyCircularQueue(int k){ q = new int[k]; }
    public boolean enQueue(int x){
        if(isFull()) return false;
        q[tail] = x;
        tail = (tail + 1) % q.length; size++; return true;
    }
    public boolean deQueue(){
        if(isEmpty()) return false;
        head = (head + 1) % q.length; size--; return true;
    }
    public int Front(){ return isEmpty() ? -1 : q[head]; }
    public int Rear(){ return isEmpty() ? -1 : q[(tail - 1 + q.length) % q.length]; }
    public boolean isEmpty(){ return size==0; }
    public boolean isFull(){ return size==q.length; }
}
```

---

## 7) 循环双端队列 Circular Deque
```java
class MyCircularDeque {
    int[] q; int head=0, tail=0, size=0;
    public MyCircularDeque(int k){ q=new int[k]; }
    public boolean insertFront(int x){
        if(isFull()) return false;
        head = (head - 1 + q.length) % q.length;
        q[head] = x; size++; return true;
    }
    public boolean insertLast(int x){
        if(isFull()) return false;
        q[tail] = x; tail = (tail + 1) % q.length; size++; return true;
    }
    public boolean deleteFront(){
        if(isEmpty()) return false;
        head = (head + 1) % q.length; size--; return true;
    }
    public boolean deleteLast(){
        if(isEmpty()) return false;
        tail = (tail - 1 + q.length) % q.length; size--; return true;
    }
    public int getFront(){ return isEmpty()? -1 : q[head]; }
    public int getRear(){ return isEmpty()? -1 : q[(tail - 1 + q.length) % q.length]; }
    public boolean isEmpty(){ return size==0; }
    public boolean isFull(){ return size==q.length; }
}
```

---

## 8) Trie（前缀树）
- 支持 `insert`, `search(word)`, `startsWith(prefix)`。

```java
class Trie {
    static class Node {
        Node[] c = new Node[26];
        boolean end;
    }
    private final Node root = new Node();

    public void insert(String s){
        Node p = root;
        for(char ch: s.toCharArray()){
            int i = ch - 'a';
            if(p.c[i]==null) p.c[i] = new Node();
            p = p.c[i];
        }
        p.end = true;
    }
    public boolean search(String s){
        Node p = walk(s);
        return p!=null && p.end;
    }
    public boolean startsWith(String s){
        return walk(s)!=null;
    }
    private Node walk(String s){
        Node p = root;
        for(char ch: s.toCharArray()){
            int i = ch - 'a';
            if(i<0 || i>=26 || p.c[i]==null) return null;
            p = p.c[i];
        }
        return p;
    }
}
```

---

## 9) 并查集 Union-Find（路径压缩 + 按秩合并）
```java
class UnionFind {
    int[] p, r, sz; int count;
    public UnionFind(int n){
        p = new int[n]; r = new int[n]; sz = new int[n];
        for(int i=0;i<n;i++){ p[i]=i; r[i]=0; sz[i]=1; }
        count = n;
    }
    public int find(int x){
        if(p[x]!=x) p[x]=find(p[x]);
        return p[x];
    }
    public boolean union(int a, int b){
        int pa=find(a), pb=find(b);
        if(pa==pb) return false;
        if(r[pa]<r[pb]) { p[pa]=pb; sz[pb]+=sz[pa]; }
        else if(r[pa]>r[pb]) { p[pb]=pa; sz[pa]+=sz[pb]; }
        else { p[pb]=pa; r[pa]++; sz[pa]+=sz[pb]; }
        count--; return true;
    }
    public boolean connected(int a, int b){ return find(a)==find(b); }
    public int size(int x){ return sz[find(x)]; }
    public int groups(){ return count; }
}
```

---

## 10) RandomizedSet（O(1) 插删查 + 随机）
- 思路：ArrayList 存值 + HashMap 记录值到索引；删除时与末尾交换后弹出。

# LFU Cache (Least Frequently Used) — O(1) 实现详解

## 一、核心思想
LFU（最不经常使用）缓存要在 **O(1)** 时间内完成四种操作：
- `get(key)`
- `put(key, value)`
- 更新访问频率
- 删除最低频率节点

传统方案用最小堆难以做到 O(1)，因此采用 **双哈希 + 双链表结构**。

---

## 二、数据结构设计

### 1. `Map<Integer, Node> keyTable`
存 key → Node 映射，支持 O(1) 查找节点。

### 2. `Map<Integer, LinkedHashSet<Node>> freqTable`
存频率 → 对应节点集合。  
`LinkedHashSet` 维持插入顺序，支持 O(1) 插入与删除。

### 3. 变量
- `int minFreq`：记录当前最小频率，用于快速删除。
- `int capacity`：缓存容量。

---

## 三、节点定义

```java
class Node {
    int key, val, freq;
    Node(int k, int v) {
        key = k;
        val = v;
        freq = 1; // 新节点初始频率为 1
    }
}


```java
import java.util.*;

class RandomizedSet {
    List<Integer> a = new ArrayList<>();
    Map<Integer,Integer> pos = new HashMap<>();
    Random rnd = new Random();
    public boolean insert(int val){
        if(pos.containsKey(val)) return false;
        pos.put(val, a.size());
        a.add(val);
        return true;
    }
    public boolean remove(int val){
        Integer i = pos.get(val);
        if(i==null) return false;
        int last = a.get(a.size()-1);
        Collections.swap(a, i, a.size()-1);
        pos.put(last, i);
        a.remove(a.size()-1);
        pos.remove(val);
        return true;
    }
    public int getRandom(){ return a.get(rnd.nextInt(a.size())); }
}
```

---

## 11) 线段树 Segment Tree（区间和，点更新）
- 接口：`build`, `update(idx, val)`, `query(L, R)`。

```java
class SegmentTree {
    int n;
    int[] tree;
    public SegmentTree(int[] arr){
        n = arr.length;
        tree = new int[4*n];
        build(1,0,n-1,arr);
    }
    private void build(int p,int l,int r,int[] a){
        if(l==r){ tree[p]=a[l]; return; }
        int m=(l+r)/2;
        build(p*2,l,m,a);
        build(p*2+1,m+1,r,a);
        tree[p]=tree[p*2]+tree[p*2+1];
    }
    public void update(int idx,int val){ update(1,0,n-1,idx,val); }
    private void update(int p,int l,int r,int idx,int val){
        if(l==r){ tree[p]=val; return; }
        int m=(l+r)/2;
        if(idx<=m) update(p*2,l,m,idx,val);
        else update(p*2+1,m+1,r,idx,val);
        tree[p]=tree[p*2]+tree[p*2+1];
    }
    public int query(int L,int R){ return query(1,0,n-1,L,R); }
    private int query(int p,int l,int r,int L,int R){
        if(R<l || r<L) return 0;
        if(L<=l && r<=R) return tree[p];
        int m=(l+r)/2;
        return query(p*2,l,m,L,R)+query(p*2+1,m+1,r,L,R);
    }
}
```

---

## 12) 树状数组 Fenwick Tree（区间和，点更新）
- 核心：低位元 `i & -i`。

```java
class Fenwick {
    int n; int[] bit;
    public Fenwick(int n){
        this.n=n; bit=new int[n+1];
    }
    public void add(int i,int delta){
        for(; i<=n; i+= i&-i) bit[i]+=delta;
    }
    public int sumPrefix(int i){
        int s=0;
        for(; i>0; i-= i&-i) s+=bit[i];
        return s;
    }
    public int sumRange(int l,int r){ return sumPrefix(r)-sumPrefix(l-1); }
}
```

---

## 13) 单调队列 Monotonic Queue（滑动窗口最大值）
- 维护队首为当前窗口最大值的下标。

```java
import java.util.*;

class MonotonicQueue {
    Deque<Integer> dq = new ArrayDeque<>();
    public void push(int i, int[] a){
        while(!dq.isEmpty() && a[dq.peekLast()] <= a[i]) dq.pollLast();
        dq.offerLast(i);
    }
    public void pop(int i){ if(!dq.isEmpty() && dq.peekFirst()==i) dq.pollFirst(); }
    public int max(int[] a){ return a[dq.peekFirst()]; }
}
```

---

## 复杂度总览 Summary
| 结构 | 关键操作 | 时间复杂度 | 空间 |
|---|---|---|---|
| LRU（手写） | get/put | O(1) | O(n) |
| MyStack（队列实现） | push / pop | O(n) / O(1) 或反之 | O(n) |
| MyQueue（栈实现） | push/pop/peek | 均摊 O(1) | O(n) |
| MinStack | push/pop/top/getMin | O(1) | O(n) |
| LFU | get/put | O(1) | O(n) |
| Circular Queue/Deque | en/deQueue | O(1) | O(k) |
| Trie | insert/search | O(L) | O(Σ·N) |
| Union-Find | find/union | 近似 O(1) | O(n) |
| RandomizedSet | insert/remove/getRandom | O(1) | O(n) |
| Segment Tree | update/query | O(log n) | O(n) |
| Fenwick Tree | add/sum | O(log n) | O(n) |
| Monotonic Queue | push/pop/max | O(1) | O(n) |

---

### 使用建议
- 需要 O(1) 最近最少使用：优先 LRU；频次淘汰用 LFU。  
- 多次区间查询+点更新：Fenwick 或 Segment Tree。  
- 短字符串查找：Trie。  
- 连通性与合并：Union-Find。  
- 数据流维护窗口极值：Monotonic Queue。
