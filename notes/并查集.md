# 并查集（Union-Find / Disjoint Set Union, DSU）详解

---

## 一、核心功能 (Core Functions)

1. **find(x)**：查找元素 x 所在集合的代表（根节点）。
   **find(x)**: Find the representative (root) of the set containing x.

2. **union(x, y)**：合并 x 与 y 所在的两个集合。
   **union(x, y)**: Merge the sets containing x and y.

3. **connected(x, y)**：判断 x 和 y 是否属于同一集合。
   **connected(x, y)**: Check if x and y belong to the same set.

---

## 二、数据结构设计 (Data Structure Design)

```java
class UnionFind {
    int[] parent;  // parent[i] 表示节点 i 的父节点
    int[] rank;    // rank[i] 表示以 i 为根的树的高度，用于优化

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i; // 初始化时每个节点是独立的
    }

    // 查找操作 + 路径压缩 (Find with Path Compression)
    public int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]); // 递归压缩路径
        return parent[x];
    }

    // 合并操作 + 按秩合并 (Union by Rank)
    public void union(int x, int y) {
        int rootX = find(x), rootY = find(y);
        if (rootX == rootY) return; // 已在同一集合

        if (rank[rootX] < rank[rootY]) parent[rootX] = rootY;
        else if (rank[rootX] > rank[rootY]) parent[rootY] = rootX;
        else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }

    // 判断是否连通 (Check connectivity)
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```

---

## 三、复杂度分析 (Complexity Analysis)

* **时间复杂度 (Time Complexity)**：O(α(n)) ≈ O(1)，α 为阿克曼函数的反函数。
* **空间复杂度 (Space Complexity)**：O(n)。

---

## 四、典型应用场景 (Common Applications)

| 场景 (Scenario)              | 说明 (Description) | 典型题目 (Typical Problem)                                        |
| -------------------------- | ---------------- | ------------------------------------------------------------- |
| 连通性判断 Connectivity         | 判断图中两点是否连通       | LeetCode 547. Number of Provinces                             |
| Kruskal 最小生成树 MST          | 用并查集避免成环         | LeetCode 1584. Min Cost to Connect All Points                 |
| 动态连通性 Dynamic Connectivity | 动态加入边维护连通块数量     | LeetCode 1319. Number of Operations to Make Network Connected |
| 检测环 Redundant Connection   | 找出图中第一条成环的边      | LeetCode 684. Redundant Connection                            |
| 动态岛屿数量                     | 合并陆地块统计岛屿数       | LeetCode 305. Number of Islands II                            |

---

## 五、Kruskal 算法示例 (Example: Kruskal's Minimum Spanning Tree)

```java
class Solution {
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        List<int[]> edges = new ArrayList<>();
        // 构造所有边 (Construct all edges)
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int w = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
                edges.add(new int[]{i, j, w});
            }
        }

        // 按权重排序 (Sort by weight)
        edges.sort(Comparator.comparingInt(a -> a[2]));

        UnionFind uf = new UnionFind(n);
        int cost = 0, count = 0;
        for (int[] e : edges) {
            if (!uf.connected(e[0], e[1])) {
                uf.union(e[0], e[1]);
                cost += e[2];
                count++;
                if (count == n - 1) break;
            }
        }
        return cost;
    }
}
```

---

## 六、优化要点 (Optimization Points)

* **路径压缩 Path Compression**：递归将节点直接挂到根节点上。
* **按秩合并 Union by Rank**：小树挂大树，保持树结构扁平。
* **按大小合并 Union by Size**：用集合大小代替 rank，更直观。

---

## 七、总结 (Summary)

| 优化策略 (Optimization)   | 原理 (Principle) | 效果 (Effect) |
| --------------------- | -------------- | ----------- |
| 路径压缩 Path Compression | 将路径上节点直接指向根节点  | 极大减少树高      |
| 按秩合并 Union by Rank    | 小树并入大树         | 保持树平衡       |
| 按大小合并 Union by Size   | 按节点数量合并        | 实现同样优化效果    |

并查集是处理**动态连通性问题**的最优结构之一，核心在于**树结构 + 路径压缩 + 按秩合并**三者结合。
